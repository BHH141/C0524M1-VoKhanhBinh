<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetris Game</title>
</head>
<body>
<canvas id="tetris-canvas" width="420" height="600"></canvas>
<script>
    class Game {
        constructor() {
            this.score = 0;
            this.boardWidth = 10;
            this.boardHeight = 23;
            this.currentTetromino = null;
            this.currentBoard = new Array(this.boardHeight).fill(0).map(() => new Array(this.boardWidth).fill(0));
            this.landedBoard = new Array(this.boardHeight).fill(0).map(() => new Array(this.boardWidth).fill(0))
            this.canvas = document.getElementById('tetris-canvas');
            this.ctx = this.canvas.getContext('2d');
        }
        //Phương thức để vẽ toàn bộ bảng trò chơi.
        draw() {
            let blockSize = 24;
            let padding = 4;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.rect(padding, padding, blockSize * this.boardWidth + padding * (this.boardWidth + 1), blockSize * (this.boardHeight - 3) + padding * (this.boardHeight - 3 + 1));
            this.ctx.stroke();
            for (let i = 3; i < this.boardHeight; i++) {
                for (let j = 0; j < this.boardWidth; j++) {
                    if (this.currentBoard[i][j] > 0) {
                        this.ctx.fillStyle = "rgb(0, 0, 0)";
                    } else {
                        this.ctx.fillStyle = "rgb(248, 248, 248)";
                    }
                    this.ctx.fillRect(padding * 2 + j * (blockSize + padding), padding * 2 + (i - 3) * (blockSize + padding), blockSize, blockSize);
                }
            }
            this.ctx.fillStyle = "rgb(0, 0, 0)";
            this.ctx.font = "28px";
            this.ctx.fillText("TIẾP THEO:", 300, 28);
            this.ctx.fillText("ĐIỂM SỐ:", 300, 200);
            this.ctx.fillText(this.score.toString(), 300, 230);
        }
        //Phương thức để tạo ngẫu nhiên một khối tetromino.
        randomTetromino() {
            let randNum = Math.floor(Math.random() * Math.floor(7));
            switch (randNum) {
                case 0:
                    return new LShape(1, 4);
                case 1:
                    return new JShape(1, 4);
                case 2:
                    return new OShape(2, 4);
                case 3:
                    return new TShape(2, 4);
                case 4:
                    return new SShape(2, 4);
                case 5:
                    return new ZShape(2, 4);
                case 6:
                    return new IShape(0, 4);
            }
        }
        //Phương thức kiểm tra nếu khối tetromino chạm đáy.
        bottomOverlapped(tetromino) {
            if (tetromino.row + tetromino.height > this.boardHeight) {
                return true;
            } else {
                return false;
            }
        }
        //Phương thức kiểm tra nếu khối tetromino chạm vào khối đã tiếp đất.
        landedOverlapped(tetromino) {
            for (let i = 0; i < tetromino.height; i++) {
                for (let j = 0; j < tetromino.width; j++) {
                    if (tetromino.shape[i][j] > 0 && this.landedBoard[tetromino.row + i][tetromino.col + j] > 0) {
                        return true;
                    }
                }
            }
            return false;
        }
        //Phương thức để hợp nhất khối hiện tại vào bảng đã tiếp đất.
        mergeCurrentTetromino() {
            for (let i = 0; i < this.currentTetromino.height; i++) {
                for (let j = 0; j < this.currentTetromino.width; j++) {
                    if (this.currentTetromino.shape[i][j] > 0) {
                        this.landedBoard[this.currentTetromino.row + i][this.currentTetromino.col + j] = this.currentTetromino.shape[i][j];
                    }
                }
            }
        }
        //Phương thức để tiến hành trò chơi
        progress() {
            if (this.currentTetromino) {
                let nextTetromino = new this.currentTetromino.constructor(this.currentTetromino.row + 1, this.currentTetromino.col, this.currentTetromino.angle);
                if (!this.bottomOverlapped(nextTetromino) && !this.landedOverlapped(nextTetromino)) {
                    this.currentTetromino.fall();
                } else {
                    this.mergeCurrentTetromino();
                    this.currentTetromino = this.randomTetromino();
                }
            }
        }
        tryMoveDown() {
            this.progress();
            this.updateCurrentBoard();
            this.draw();
        }
        leftOverlapped(tetromino) {
            if (tetromino.col < 0) {
                return true
            } else {
                return false
            }
        }
        rightOverlapped(tetromino) {
            if (tetromino.col + tetromino.width > this.boardWidth) {
                return true
            } else {
                return false
            }
        }
        tryMoveLeft() {
            const tempTetromino = new this.currentTetromino.constructor(this.currentTetromino.row, this.currentTetromino.col - 1, this.currentTetromino.angle)
            if (!this.leftOverlapped(tempTetromino) &&
                !this.landedOverlapped(tempTetromino)) {
                this.currentTetromino.col -= 1
                this.updateCurrentBoard()
                this.draw()
            }
        }
        tryMoveRight() {
            const tempTetromino = new this.currentTetromino.constructor(this.currentTetromino.row, this.currentTetromino.col + 1, this.currentTetromino.angle)
            if (!this.rightOverlapped(tempTetromino) &&
                !this.landedOverlapped(tempTetromino)) {
                this.currentTetromino.col += 1
                this.updateCurrentBoard()
                this.draw()
            }
        }
        tryRotating() {
            const tempTetromino = new this.currentTetromino.constructor(this.currentTetromino.row, this.currentTetromino.col, this.currentTetromino.angle)
            tempTetromino.rotate()
            if (!this.rightOverlapped(tempTetromino) &&
                !this.bottomOverlapped(tempTetromino) &&
                !this.landedOverlapped(tempTetromino)) {
                this.currentTetromino.rotate()
                this.updateCurrentBoard()
                this.draw()
            }
        }
        //Phương thức để cập nhật bảng hiện tại.
        updateCurrentBoard() {
            for (let i = 0; i < this.boardHeight; i++) {
                for (let j = 0; j < this.boardWidth; j++) {
                    this.currentBoard[i][j] = this.landedBoard[i][j];
                }
            }
            for (let i = 0; i < this.currentTetromino.height; i++) {
                for (let j = 0; j < this.currentTetromino.width; j++) {
                    if (this.currentTetromino.shape[i][j] > 0) {
                        this.currentBoard[this.currentTetromino.row + i][this.currentTetromino.col + j] = this.currentTetromino.shape[i][j];
                    }
                }
            }
        }
        play() {
            setInterval(() => {
                this.tryMoveDown();
            }, 800);
        }
    }
    class Tetromino {
        constructor(row, col) {
            let angle = 0;
            this.row = row;
            this.col = col;
            this.angle = angle;
        }
        get shape() {
            return this.constructor.shapes[this.angle];
        }
        get width() {
            return this.shape[0].length;
        }
        get height() {
            return this.shape.length;
        }
        fall() {
            this.row += 1;
        }
        rotate() {
            this.angle = (this.angle + 1) % 4;
        }
    }
    class LShape extends Tetromino { }
    LShape.shapes = [
        [[1, 0],
            [1, 0],
            [1, 1]],

        [[1, 1, 1],
            [1, 0, 0]],

        [[1, 1],
            [0, 1],
            [0, 1]],

        [[0, 0, 1],
            [1, 1, 1]]
    ];
    LShape.color = "rgb(255, 87, 34)";
    class JShape extends Tetromino { }
    JShape.shapes = [
        [[0, 2],
            [0, 2],
            [2, 2]],

        [[2, 0, 0],
            [2, 2, 2]],

        [[2, 2],
            [2, 0],
            [2, 0]],

        [[2, 2, 2],
            [0, 0, 2]]
    ];
    JShape.color = "rgb(63, 81, 181)";
    class OShape extends Tetromino { }
    OShape.shapes = [
        [[3, 3],
            [3, 3]],

        [[3, 3],
            [3, 3]],

        [[3, 3],
            [3, 3]],

        [[3, 3],
            [3, 3]]
    ];
    OShape.color = "rgb(255, 235, 59)";
    class TShape extends Tetromino { }
    TShape.shapes = [
        [[0, 4, 0],
            [4, 4, 4]],

        [[4, 0],
            [4, 4],
            [4, 0]],

        [[4, 4, 4],
            [0, 4, 0]],

        [[0, 4],
            [4, 4],
            [0, 4]]
    ];
    TShape.color = "rgb(156, 39, 176)";
    class SShape extends Tetromino { }
    SShape.shapes = [
        [[0, 5, 5],
            [5, 5, 0]],

        [[5, 0],
            [5, 5],
            [0, 5]],

        [[0, 5, 5],
            [5, 5, 0]],

        [[5, 0],
            [5, 5],
            [0, 5]]
    ];
    SShape.color = "rgb(76, 175, 80)";
    class ZShape extends Tetromino { }
    ZShape.shapes = [
        [[6, 6, 0],
            [0, 6, 6]],

        [[0, 6],
            [6, 6],
            [6, 0]],

        [[6, 6, 0],
            [0, 6, 6]],

        [[0, 6],
            [6, 6],
            [6, 0]]
    ];
    ZShape.color = "rgb(183, 28, 28)";
    class IShape extends Tetromino { }
    IShape.shapes = [
        [[7],
            [7],
            [7],
            [7]],

        [[7, 7, 7, 7]],

        [[7],
            [7],
            [7],
            [7]],

        [[7, 7, 7, 7]]
    ];
    IShape.color = "rgb(0, 188, 212)";

    const game = new Game();

    window.addEventListener('keydown', (event) => {
        switch (event.keyCode) {
            case 37:
                game.tryMoveLeft();
                break;
            case 39:
                game.tryMoveRight();
                break;
            case 38:
                game.tryRotating();
                break;
            case 40:
                game.tryMoveDown();
                break;
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        game.currentTetromino = game.randomTetromino();
        game.updateCurrentBoard();
        game.draw();
        game.play();
    });
</script>
</body>
</html>
