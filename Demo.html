<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetris Game</title>
</head>
<body>
<canvas id="tetris-canvas" width="420" height="600"></canvas>
<script>
    class Game {
        constructor() {
            this.score = 0;
            this.boardWidth = 10;
            this.boardHeight = 20;
            this.currentTetromino = null;
            this.currentBoard = Array.from({ length: this.boardHeight }, () => Array(this.boardWidth).fill(0));
            this.landedBoard = Array.from({ length: this.boardHeight }, () => Array(this.boardWidth).fill(0));
            this.canvas = document.getElementById('tetris-canvas');
            this.ctx = this.canvas.getContext('2d');
        }

        draw() {
            const blockSize = 24;
            const padding = 4;
            const offsetY = 3; // Offset for the hidden rows

            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.strokeRect(
                padding,
                padding,
                blockSize * this.boardWidth + padding * (this.boardWidth + 1),
                blockSize * (this.boardHeight - offsetY) + padding * (this.boardHeight - offsetY + 1)
            );

            for (let i = offsetY; i < this.boardHeight; i++) {
                for (let j = 0; j < this.boardWidth; j++) {
                    this.ctx.fillStyle = this.getColor(this.currentBoard[i][j]) || "rgb(248, 248, 248)";
                    this.ctx.fillRect(
                        padding * 2 + j * (blockSize + padding),
                        padding * 2 + (i - offsetY) * (blockSize + padding),
                        blockSize,
                        blockSize
                    );
                }
            }

            this.ctx.fillStyle = "rgb(0, 0, 0)";
            this.ctx.font = "28px Arial";
            this.ctx.fillText("Score:", 300, 28);
            this.ctx.fillText(this.score.toString(), 300, 58);
        }

        randomTetromino() {
            const randNum = Math.floor(Math.random() * 7);
            switch (randNum) {
                case 0: return new LShape(1, 4);
                case 1: return new JShape(1, 4);
                case 2: return new OShape(2, 4);
                case 3: return new TShape(2, 4);
                case 4: return new SShape(2, 4);
                case 5: return new ZShape(2, 4);
                case 6: return new IShape(0, 4);
            }
        }

        getColor(cellNumber) {
            switch (cellNumber) {
                case 1: return LShape.color;
                case 2: return JShape.color;
                case 3: return OShape.color;
                case 4: return TShape.color;
                case 5: return SShape.color;
                case 6: return ZShape.color;
                case 7: return IShape.color;
                default: return null;
            }
        }

        bottomOverlapped(tetromino) {
            return tetromino.row + tetromino.height > this.boardHeight;
        }

        landedOverlapped(tetromino) {
            for (let i = 0; i < tetromino.height; i++) {
                for (let j = 0; j < tetromino.width; j++) {
                    if (tetromino.shape[i][j] > 0 && this.landedBoard[tetromino.row + i][tetromino.col + j] > 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        mergeCurrentTetromino() {
            for (let i = 0; i < this.currentTetromino.height; i++) {
                for (let j = 0; j < this.currentTetromino.width; j++) {
                    if (this.currentTetromino.shape[i][j] > 0) {
                        this.landedBoard[this.currentTetromino.row + i][this.currentTetromino.col + j] = this.currentTetromino.shape[i][j];
                    }
                }
            }
        }

        progress() {
            if (this.currentTetromino) {
                const nextTetromino = new this.currentTetromino.constructor(this.currentTetromino.row + 1, this.currentTetromino.col, this.currentTetromino.angle);
                if (!this.bottomOverlapped(nextTetromino) && !this.landedOverlapped(nextTetromino)) {
                    this.currentTetromino.fall();
                } else {
                    this.mergeCurrentTetromino();
                    this.clearRows();
                    this.currentTetromino = this.randomTetromino();
                    if (this.landedOverlapped(this.currentTetromino)) {
                        this.isGameOver = true;
                        alert("Game Over! Final Score: " + this.score);
                        return;
                    }
                }
            }
            this.checkGameOver();
        }

        moveToBottom() {
            while (!this.bottomOverlapped(this.currentTetromino) && !this.landedOverlapped(new this.currentTetromino.constructor(this.currentTetromino.row + 1, this.currentTetromino.col, this.currentTetromino.angle))) {
                this.currentTetromino.fall();
            }
            this.progress();
            this.updateCurrentBoard();
            this.draw();
        }

        tryMoveDown() {
            this.progress();
            this.updateCurrentBoard();
            this.draw();
        }

        leftOverlapped(tetromino) {
            return tetromino.col < 0;
        }

        rightOverlapped(tetromino) {
            return tetromino.col + tetromino.width > this.boardWidth;
        }

        tryMoveLeft() {
            const tempTetromino = new this.currentTetromino.constructor(this.currentTetromino.row, this.currentTetromino.col - 1, this.currentTetromino.angle);
            if (!this.leftOverlapped(tempTetromino) && !this.landedOverlapped(tempTetromino)) {
                this.currentTetromino.col -= 1;
                this.updateCurrentBoard();
                this.draw();
            }
        }

        tryMoveRight() {
            const tempTetromino = new this.currentTetromino.constructor(this.currentTetromino.row, this.currentTetromino.col + 1, this.currentTetromino.angle);
            if (!this.rightOverlapped(tempTetromino) && !this.landedOverlapped(tempTetromino)) {
                this.currentTetromino.col += 1;
                this.updateCurrentBoard();
                this.draw();
            }
        }

        tryRotating() {
            const tempTetromino = new this.currentTetromino.constructor(this.currentTetromino.row, this.currentTetromino.col, this.currentTetromino.angle);
            tempTetromino.rotate();
            if (!this.rightOverlapped(tempTetromino) && !this.bottomOverlapped(tempTetromino) && !this.landedOverlapped(tempTetromino)) {
                this.currentTetromino.rotate();
                this.updateCurrentBoard();
                this.draw();
            }
        }

        updateCurrentBoard() {
            for (let i = 0; i < this.boardHeight; i++) {
                for (let j = 0; j < this.boardWidth; j++) {
                    this.currentBoard[i][j] = this.landedBoard[i][j];
                }
            }
            for (let i = 0; i < this.currentTetromino.height; i++) {
                for (let j = 0; j < this.currentTetromino.width; j++) {
                    if (this.currentTetromino.shape[i][j] > 0) {
                        this.currentBoard[this.currentTetromino.row + i][this.currentTetromino.col + j] = this.currentTetromino.shape[i][j];
                    }
                }
            }
        }

        findClearableRows() {
            const fullRows = [];
            for (let i = 0; i < this.landedBoard.length; i++) {
                if (this.landedBoard[i].every(cell => cell > 0)) {
                    fullRows.push(i);
                }
            }
            return fullRows;
        }

        clearRows() {
            const clearableRows = this.findClearableRows();
            if (clearableRows.length === 0) return;

            for (let rowIndex of clearableRows) {
                this.landedBoard.splice(rowIndex, 1);
                this.landedBoard.unshift(Array(this.boardWidth).fill(0));
            }
            this.score += clearableRows.length * 100;
        }

        checkGameOver() {
            if (this.landedBoard[3].some(cell => cell > 0)) {
                this.isGameOver = true;
                alert("Game Over! Final Score: " + this.score);
            }
        }

        play() {
            setInterval(() => {
                if (!this.isGameOver) {
                    this.progress();
                    this.updateCurrentBoard();
                    this.draw();
                }
            }, 800);
        }
    }

    class Tetromino {
        constructor(row, col) {
            this.row = row;
            this.col = col;
            this.angle = 0;
            this.shape = this.shapes[0];
        }

        fall() {
            this.row++;
        }

        rotate() {
            this.angle = (this.angle + 90) % 360;
            this.shape = this.shapes[this.angle / 90];
        }
    }

    class LShape extends Tetromino {
        constructor(row, col) {
            super(row, col);
            this.shapes = [
                [
                    [1, 0],
                    [1, 0],
                    [1, 1]
                ],
                [
                    [0, 0, 1],
                    [1, 1, 1]
                ],
                [
                    [1, 1],
                    [0, 1],
                    [0, 1]
                ],
                [
                    [1, 1, 1],
                    [1, 0, 0]
                ]
            ];
            this.shape = this.shapes[0];
        }
    }
    LShape.color = "rgb(255, 165, 0)";

    class JShape extends Tetromino {
        constructor(row, col) {
            super(row, col);
            this.shapes = [
                [
                    [0, 2],
                    [0, 2],
                    [2, 2]
                ],
                [
                    [2, 2, 2],
                    [0, 0, 2]
                ],
                [
                    [2, 2],
                    [2, 0],
                    [2, 0]
                ],
                [
                    [2, 0, 0],
                    [2, 2, 2]
                ]
            ];
            this.shape = this.shapes[0];
        }
    }
    JShape.color = "rgb(0, 0, 255)";

    class OShape extends Tetromino {
        constructor(row, col) {
            super(row, col);
            this.shapes = [
                [
                    [3, 3],
                    [3, 3]
                ]
            ];
            this.shape = this.shapes[0];
        }
    }
    OShape.color = "rgb(255, 255, 0)";

    class TShape extends Tetromino {
        constructor(row, col) {
            super(row, col);
            this.shapes = [
                [
                    [0, 4, 0],
                    [4, 4, 4]
                ],
                [
                    [4, 0],
                    [4, 4],
                    [4, 0]
                ],
                [
                    [4, 4, 4],
                    [0, 4, 0]
                ],
                [
                    [0, 4],
                    [4, 4],
                    [0, 4]
                ]
            ];
            this.shape = this.shapes[0];
        }
    }
    TShape.color = "rgb(128, 0, 128)";

    class SShape extends Tetromino {
        constructor(row, col) {
            super(row, col);
            this.shapes = [
                [
                    [0, 5, 5],
                    [5, 5, 0]
                ],
                [
                    [5, 0],
                    [5, 5],
                    [0, 5]
                ]
            ];
            this.shape = this.shapes[0];
        }
    }
    SShape.color = "rgb(0, 255, 0)";

    class ZShape extends Tetromino {
        constructor(row, col) {
            super(row, col);
            this.shapes = [
                [
                    [6, 6, 0],
                    [0, 6, 6]
                ],
                [
                    [0, 6],
                    [6, 6],
                    [6, 0]
                ]
            ];
            this.shape = this.shapes[0];
        }
    }
    ZShape.color = "rgb(255, 0, 0)";

    class IShape extends Tetromino {
        constructor(row, col) {
            super(row, col);
            this.shapes = [
                [
                    [7],
                    [7],
                    [7],
                    [7]
                ],
                [
                    [7, 7, 7, 7]
                ]
            ];
            this.shape = this.shapes[0];
        }
    }
    IShape.color = "rgb(0, 255, 255)";

    const game = new Game();
    game.currentTetromino = game.randomTetromino();
    game.play();
    window.addEventListener("keydown", (event) => {
        if (!game.isGameOver) {
            switch (event.key) {
                case "ArrowUp":
                    game.tryRotating();
                    break;
                case "ArrowDown":
                    game.tryMoveDown();
                    break;
                case "ArrowLeft":
                    game.tryMoveLeft();
                    break;
                case "ArrowRight":
                    game.tryMoveRight();
                    break;
                case " ":
                    game.moveToBottom();
                    break;
            }
        }
    });
</script>
</body>
</html>
